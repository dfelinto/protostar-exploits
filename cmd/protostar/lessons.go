package main

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"strconv"
)

const (
	inputArgument    int = 0
	inputPipe            = 1
	inputEnvironment     = 2
)

type stack interface {
	get_lesson_name() string
	get_input_data() []byte
	get_input_method() int
	get_environment_key() string
}

func run_lesson(s stack) {
	fmt.Println(("Starting lesson ..."))

	target_binary := get_target_binary(s)
	password := s.get_input_data()

	inputMethod := s.get_input_method()

	switch inputMethod {
	case inputPipe:
		populate_input(s, target_binary, password)
	case inputArgument:
		pass_argument(s, target_binary, password)
	case inputEnvironment:
		environmentKey := s.get_environment_key()
		pass_enviroment(s, target_binary, environmentKey, password)

	default:
		errorMessage := "Assert! input method not implemented: "
		errorMessage += strconv.Itoa(inputMethod)
		_ = errors.New(errorMessage)
	}
}

func get_target_binary(s stack) string {
	return "/opt/protostar/bin/" + s.get_lesson_name()
}

func fill_byte_array(array []byte, data byte) {
	for i := 0; i < len(array); i++ {
		array[i] = data
	}
}

func fill_byte_array_ordered_ex(array []byte, initialChar byte, sequenceLen int) {
	data := initialChar
	for i := 0; i < len(array); i++ {
		array[i] = data

		/* Increase to '\xBB' */
		if (i+1)%sequenceLen == 0 {
			data++
		}
	}
}

func fill_byte_array_ordered(array []byte) {
	fill_byte_array_ordered_ex(array, 'A', 4)
}

func populate_input(s stack, target_binary string, password []byte) {
	fmt.Println("Trying to exploit: " + target_binary)
	cmdTarget := exec.Command(target_binary)
	cmdTarget.Stdout = os.Stdout
	cmdTarget.Stderr = os.Stderr

	stdin, _ := cmdTarget.StdinPipe()
	defer stdin.Close()

	_ = cmdTarget.Start()
	stdin.Write(password)
}

func pass_argument(s stack, target_binary string, password []byte) {
	fmt.Println("Trying to exploit: " + target_binary)
	cmdTarget := exec.Command(target_binary, string(password))
	cmdTarget.Stdout = os.Stdout
	cmdTarget.Stderr = os.Stderr

	_ = cmdTarget.Start()
}

func pass_enviroment(s stack, target_binary string, environmentKey string, password []byte) {
	fmt.Println("Trying to exploit: " + target_binary)

	os.Setenv(environmentKey, string(password))

	cmdTarget := exec.Command(target_binary)
	cmdTarget.Stdout = os.Stdout
	cmdTarget.Stderr = os.Stderr

	_ = cmdTarget.Start()
}

func dump_password_to_file(password []byte, filepath string) {
	fmt.Println("Writing to: " + filepath)
	err := os.WriteFile(filepath, password, 0644)
	if err != nil {
		panic(err)
	}
}

/*
Insert code into the beggining of buffer, overriding existing content.
Return new []byte with the code and the rest of the buffer.
*/
func slide_code_into_buffer(buffer []byte, code []byte) []byte {
	lenCode := len(code)

	if lenCode > len(buffer) {
		panic("Code array is larger than buffer's")
	}

	result := code[:]
	result = append(result, buffer[lenCode:]...)

	return result
}
